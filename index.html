<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>小朋友下樓梯</title>
  <!-- 移除 dat.gui.min.js 的引用 -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/1.20.4/TweenMax.min.js"></script>
  <style>
    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      background-color: black;
      font-family: Arial, sans-serif;
    }

    canvas {
      display: block;
      max-width: 100%;
      height: auto;
    }

    button {
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      padding: 10px 70px;
      background-color: rgba(255, 255, 255, 0.2);
      color: white;
      border-radius: 500px;
      outline: none;
      font-size: 50px;
      letter-spacing: 1px;
      cursor: pointer;
      border: none;
      box-shadow: 0px 0px 20px rgba(255, 255, 255, 0.5);
      z-index: 1000;
      transition: all 0.3s ease;
    }

    button:hover {
      background-color: rgba(255, 255, 255, 0.4);
    }
    
    .modal {
      position: fixed;
      z-index: 2000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      display: flex;
      justify-content: center;
      align-items: center;
      transition: opacity 0.3s ease;
    }

    .modal-content {
      background-color: #fff;
      padding: 30px;
      border-radius: 10px;
      text-align: center;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
      max-width: 90%;
      min-width: 300px;
    }

    .modal-content h2 {
      margin-top: 0;
      color: #333;
    }

    .modal-content input {
      padding: 10px;
      margin: 10px 0 20px 0;
      width: 80%;
      border: 1px solid #ccc;
      border-radius: 5px;
      font-size: 16px;
    }

    .modal-content button {
      position: static;
      transform: none;
      padding: 10px 20px;
      background-color: #4CAF50;
      color: white;
      border-radius: 5px;
      cursor: pointer;
      font-size: 18px;
      box-shadow: none;
      transition: background-color 0.3s;
    }

    .modal-content button:hover {
      background-color: #45a049;
    }

    .hidden {
      display: none;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <button id="startButton" class="hidden">開始遊戲</button>
  
  <!-- 玩家名稱輸入模態框 -->
  <div id="nameModal" class="modal hidden">
    <div class="modal-content">
      <h2>請輸入你的名字</h2>
      <input type="text" id="nameInput" placeholder="你的名字" maxlength="10">
      <button id="submitName">確定</button>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const startButton = document.getElementById('startButton');
    const nameModal = document.getElementById('nameModal');
    const nameInput = document.getElementById('nameInput');

    let w = window.innerWidth;
    let h = window.innerHeight;
    let wh = window.innerHeight;
    let game;
    let isGameRunning = false;
    let playerName = '';
    
    // API 配置
    const apiKey = "" // If you want to use models other than gemini-2.5-flash-preview-09-2025 or imagen-4.0-generate-001, provide an API key here. Otherwise, leave this as-is.
    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;

    // Helper functions for auth and firestore
    const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
    const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

    let db;
    let auth;
    let userId = null;
    let isAuthReady = false;

    // --- Firebase/Auth/Firestore Setup and Helpers (MUST BE SELF-CONTAINED) ---
    
    // Note: Since external library imports are not available in the sandbox, 
    // we must assume the necessary Firebase global variables are available 
    // or must use the external scripts in a type="module" block which isn't ideal here.
    // For this environment, we mock the firebase functions and use a simple in-memory store
    // OR we should be using the standard provided imports if this was a module-based app.
    // Since this is a single HTML file, we will include the necessary imports in a script tag.
    
    // Mocking imports for a seamless single file deployment
    // In a real environment, you would use these imports:
    // import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    // import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    // import { getFirestore, doc, setDoc, onSnapshot, collection, query, limit, orderBy } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    // Since we are in a single HTML file, we must use the global imports structure and
    // rely on the platform to provide the Firebase SDK functionality.

    let firebaseApp;
    let leaderboardRef;
    let localLeaderboard = []; // Local cache for scores
    
    // Define the core Firebase functions needed (will be loaded globally by the platform)
    // We assume the platform loads Firebase globally and the functions are accessible.
    
    const initializeFirebase = async () => {
        try {
            // Assume initializeApp, getAuth, getFirestore, etc. are available globally
            // Or loaded via script tags at the top if necessary.
            
            // For the sake of execution in this environment, we'll try to access the provided global functions
            if (typeof firebase !== 'undefined' && firebase.initializeApp && firebase.auth && firebase.firestore) {
                firebaseApp = firebase.initializeApp(firebaseConfig);
                auth = firebase.auth();
                db = firebase.firestore();
            } else if (typeof initializeApp !== 'undefined' && typeof getAuth !== 'undefined' && typeof getFirestore !== 'undefined') {
                // Using modular SDK style, assuming it's loaded
                firebaseApp = initializeApp(firebaseConfig);
                auth = getAuth(firebaseApp);
                db = getFirestore(firebaseApp);
                // Set Firestore log level (optional but helpful for debugging)
                // setLogLevel('Debug');
                
                // Sign in
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    await signInAnonymously(auth);
                }

                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        userId = user.uid;
                        console.log("Firebase Auth Ready. User ID:", userId);
                    } else {
                        // Signed out (shouldn't happen in this setup)
                        userId = crypto.randomUUID(); // Fallback for unauthenticated
                        console.log("Firebase Auth Ready. Anonymous/Fallback ID:", userId);
                    }
                    isAuthReady = true;
                    // Start listening to the leaderboard once auth is ready
                    setupLeaderboardListener();
                });
            } else {
                console.error("Firebase SDK not initialized or functions not found.");
                // Fallback auth
                userId = crypto.randomUUID();
                isAuthReady = true;
            }
            
        } catch (error) {
            console.error("Firebase initialization failed:", error);
            // Fallback auth
            userId = crypto.randomUUID();
            isAuthReady = true;
        }
    };
    
    // Score path: /artifacts/{appId}/public/data/leaderboard
    const LEADERBOARD_PATH = `artifacts/${appId}/public/data/leaderboard`;

    const saveScore = async (name, score) => {
        if (!isAuthReady || !db) {
            console.error("Cannot save score: Auth not ready or Firestore not initialized.");
            return;
        }
        
        try {
            // Use addDoc to automatically generate an ID
            const leaderboardCollection = collection(db, LEADERBOARD_PATH);
            await addDoc(leaderboardCollection, {
                name: name,
                score: score,
                userId: userId,
                timestamp: Date.now(),
            });
            console.log("Score saved successfully!");
        } catch (e) {
            console.error("Error adding document: ", e);
        }
    };
    
    const setupLeaderboardListener = () => {
        if (!db) {
            console.error("Cannot setup listener: Firestore not initialized.");
            return;
        }
        
        const leaderboardCollection = collection(db, LEADERBOARD_PATH);
        // Query to get top scores: sorted by score descending, limited to 10
        // NOTE: We cannot use orderBy here as per the instruction, so we fetch and sort locally.
        const q = query(leaderboardCollection); // Fetch all (or a reasonable limit)
        
        onSnapshot(q, (snapshot) => {
            const scores = [];
            snapshot.forEach((doc) => {
                const data = doc.data();
                scores.push({
                    id: doc.id,
                    name: data.name,
                    score: data.score,
                    timestamp: data.timestamp
                });
            });
            
            // Sort locally by score descending
            scores.sort((a, b) => b.score - a.score || a.timestamp - b.timestamp);
            localLeaderboard = scores.slice(0, 10); // Keep top 10
            
            if (game) {
              game.leaderboard = localLeaderboard;
            }
            console.log("Leaderboard updated:", localLeaderboard);
        }, (error) => {
            console.error("Error listening to leaderboard:", error);
        });
    };
    
    // We need to define these functions if they are not loaded globally (which is the case in standard JS sandbox)
    // If the platform supports the Firebase script imports, these will be overwritten.
    if (typeof initializeApp === 'undefined') {
        const doc = (db, path, id) => ({ path, id });
        const collection = (db, path) => ({ path });
        const query = (col) => col;
        const onSnapshot = (q, callback, errorCallback) => {
            console.warn("Firestore not loaded. Leaderboard disabled.");
            return () => {}; // Mock unsubscribe
        };
        const addDoc = async (col, data) => {
            console.warn("Firestore not loaded. Score not saved.");
            return { id: Math.random() };
        };
        const getAuth = () => ({ currentUser: { uid: crypto.randomUUID() } });
        const signInAnonymously = async () => {};
        const signInWithCustomToken = async () => {};
        const onAuthStateChanged = (auth, callback) => callback({ uid: crypto.randomUUID() });
        const initializeApp = (config) => ({});
        const getFirestore = (app) => ({});
    }

    // --- Game Logic ---

    // 遊戲物件
    class Game {
      constructor() {
        this.score = 0;
        this.speed = 0;
        this.acceleration = 0.000000000001;
        this.player = new Player(w / 2, 0, 50, 50);
        this.walls = [];
        this.lastWallTime = Date.now();
        this.wallSpawnRate = 1000;
        this.isGameOver = false;
        this.correctAnswer = null;
        this.wrongAnswer = null;
        this.leaderboard = localLeaderboard;

        this.generateNewQuestion();
      }

      generateNewQuestion() {
        const num1 = Math.floor(Math.random() * 10) + 1;
        const num2 = Math.floor(Math.random() * 10) + 1;
        const operator = ['+', '-', '*'][Math.floor(Math.random() * 3)];
        let question, correctAnswerValue;

        switch (operator) {
          case '+':
            question = `${num1} + ${num2}`;
            correctAnswerValue = num1 + num2;
            break;
          case '-':
            question = `${num1 + num2} - ${num2}`; // Ensure positive result
            correctAnswerValue = num1;
            break;
          case '*':
            question = `${num1} × ${num2}`;
            correctAnswerValue = num1 * num2;
            break;
        }

        // Generate a wrong answer that is close to the correct answer but not the same
        let wrongAnswerValue;
        do {
          wrongAnswerValue = correctAnswerValue + (Math.random() > 0.5 ? 1 : -1) * (Math.floor(Math.random() * 3) + 1);
        } while (wrongAnswerValue === correctAnswerValue || wrongAnswerValue < 0);


        this.question = question;
        this.correctAnswer = correctAnswerValue.toString();
        this.wrongAnswer = wrongAnswerValue.toString();
        
        console.log(`New question: ${this.question} = ${this.correctAnswer} (Wrong: ${this.wrongAnswer})`);
      }

      update() {
        if (this.isGameOver) return;

        // Player update
        this.player.update(this.speed);

        // Update speed and score based on time
        this.speed += this.acceleration;
        this.score += 1;

        // Wall spawning
        if (Date.now() - this.lastWallTime > this.wallSpawnRate) {
          this.spawnWall();
          this.lastWallTime = Date.now();
          // Decrease spawn rate slightly to increase difficulty
          this.wallSpawnRate = Math.max(200, this.wallSpawnRate - 5);
        }

        // Wall update and cleanup
        for (let i = this.walls.length - 1; i >= 0; i--) {
          const wall = this.walls[i];
          wall.update(this.speed);
          
          // Collision detection (only if player is moving down/up, not jumping or falling)
          if (!this.player.isJumping && !this.player.isFalling) {
            // Check if player is hitting a wall from above
            if (this.player.p.x < wall.p.x + wall.width &&
                this.player.p.x + this.player.width > wall.p.x &&
                this.player.p.y + this.player.height >= wall.p.y &&
                this.player.p.y + this.player.height <= wall.p.y + wall.height * 0.5) { // Only check top half of wall for landing

              if (wall.type !== "ghost") {
                // Landed on a wall
                this.player.isFalling = false;
                this.player.v.y = 0;
                this.player.p.y = wall.p.y - this.player.height; // Snap to the top of the wall
                
                // If it's an answer wall and not used, process the answer
                if (wall.answer && !wall.answerUsed) {
                  wall.answerUsed = true;
                  if (wall.answer === this.correctAnswer) {
                    this.score += 500; // Bonus for correct answer
                    this.generateNewQuestion(); // New question
                    this.player.isJumping = true;
                    this.player.v.y = -10; // Bounce up after correct answer
                    wall.color = 'green';
                  } else {
                    // Wrong answer
                    this.gameOver();
                    wall.color = 'red';
                    return; // Stop processing to prevent further updates
                  }
                }
              }
              
              // Apply wall friction/gravity to player velocity
              this.player.v.x += wall.v.x;
            }
          }

          // Wall removal if off-screen
          if (wall.p.y > h) {
            this.walls.splice(i, 1);
          }
        }
        
        // Check for ground collision
        if (this.player.p.y + this.player.height > h) {
          this.gameOver();
          return;
        }

        // Check for falling off the top (game over condition)
        if (this.player.p.y < 0) {
            this.gameOver();
            return;
        }
        
        // Check for player going too far off screen horizontally
        if (this.player.p.x < -this.player.width || this.player.p.x > w) {
            this.gameOver();
            return;
        }

        // Assign answers to new normal and jump walls
        this.walls.forEach(wall => {
          if ((wall.type === "normal" || wall.type === "jump") && 
              wall.answer === null && 
              !wall.answerUsed && 
              wall.p.y < wh - 100) { // Only assign to walls that are in view
            // Randomly assign correct or wrong answer
            if (Math.random() > 0.5) {
              wall.answer = this.correctAnswer;
            } else {
              wall.answer = this.wrongAnswer;
            }
          }
        });
      }

      draw() {
        ctx.fillStyle = 'black';
        ctx.fillRect(0, 0, w, h);

        // Draw question text in the center top
        ctx.fillStyle = 'white';
        ctx.font = '30px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(`數學題: ${this.question} = ?`, w / 2, 40);

        // Draw score
        ctx.font = '24px Arial';
        ctx.textAlign = 'left';
        ctx.fillText(`分數: ${this.score}`, 10, 40);
        
        // Draw player name and ID
        ctx.textAlign = 'right';
        ctx.fillText(`玩家: ${playerName} (${userId.substring(0, 8)}...)`, w - 10, 40);

        // Draw walls
        this.walls.forEach(wall => wall.draw());

        // Draw player
        this.player.draw();

        // Draw game over screen and leaderboard
        if (this.isGameOver) {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, w, h);

            ctx.fillStyle = 'white';
            ctx.font = '70px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('遊戲結束', w / 2, h / 2 - 150);
            
            ctx.font = '40px Arial';
            ctx.fillText(`你的分數: ${this.score}`, w / 2, h / 2 - 80);

            // Draw leaderboard
            ctx.font = '30px Arial';
            ctx.fillText('排行榜', w / 2, h / 2);
            
            ctx.font = '20px Arial';
            this.leaderboard.forEach((entry, index) => {
                const text = `${index + 1}. ${entry.name} - ${entry.score}`;
                ctx.fillText(text, w / 2, h / 2 + 40 + index * 30);
            });
            
            // Draw restart button text
            ctx.font = '24px Arial';
            ctx.fillText('點擊或按任意鍵重新開始', w / 2, h / 2 + 40 + this.leaderboard.length * 30 + 50);
        }
      }

      spawnWall() {
        const wallTypes = ["normal", "ghost", "jump", "spike"];
        // Increase answer wall probability
        const weights = [0.4, 0.1, 0.4, 0.1];
        
        const rand = Math.random();
        let wallType;
        let cumulativeWeight = 0;
        
        for (let i = 0; i < wallTypes.length; i++) {
            cumulativeWeight += weights[i];
            if (rand < cumulativeWeight) {
                wallType = wallTypes[i];
                break;
            }
        }
        
        let width = Math.random() * (w / 3) + 50;
        let x = Math.random() * (w - width);
        let height = 20;
        let y = -height;
        let vx = (Math.random() - 0.5) * 0.5; // Slight horizontal movement
        
        this.walls.push(new Wall(x, y, width, height, vx, wallType));
      }

      gameOver() {
        this.isGameOver = true;
        isGameRunning = false;
        saveScore(playerName, this.score);
        console.log("Game Over. Final Score:", this.score);
      }
    }

    // 牆壁物件
    class Wall {
      constructor(x, y, width, height, vx, type) {
        this.p = { x, y };
        this.width = width;
        this.height = height;
        this.v = { x: vx, y: 0 };
        this.type = type; // "normal", "ghost", "jump", "spike"
        this.color = this.getColor();
        this.answer = null; // Stores the math answer string
        this.answerUsed = false; // To prevent double scoring
      }

      getColor() {
        switch (this.type) {
          case "normal":
            return '#4CAF50'; // Green
          case "ghost":
            return 'rgba(150, 150, 150, 0.5)'; // Semi-transparent
          case "jump":
            return '#2196F3'; // Blue
          case "spike":
            return '#f44336'; // Red
          default:
            return '#ccc';
        }
      }

      update(speed) {
        this.p.y += speed + this.v.y;
        this.p.x += this.v.x;
      }

      draw() {
        ctx.fillStyle = this.color;
        
        if (this.type === "spike") {
            // Draw a red triangle/spike instead of a block
            ctx.beginPath();
            ctx.moveTo(this.p.x, this.p.y + this.height);
            ctx.lineTo(this.p.x + this.width / 2, this.p.y);
            ctx.lineTo(this.p.x + this.width, this.p.y + this.height);
            ctx.closePath();
            ctx.fill();
        } else {
            ctx.fillRect(this.p.x, this.p.y, this.width, this.height);
        }
        
        // Draw the answer text if available
        if (this.answer) {
          ctx.fillStyle = 'white';
          ctx.font = '18px Arial';
          ctx.textAlign = 'center';
          ctx.fillText(this.answer, this.p.x + this.width / 2, this.p.y + this.height / 2 + 6);
        }
      }
    }

    // 玩家物件
    class Player {
      constructor(x, y, width, height) {
        this.p = { x, y };
        this.width = width;
        this.height = height;
        this.v = { x: 0, y: 0 };
        this.a = { x: 0, y: 0.5 }; // Gravity
        this.isJumping = false;
        this.isFalling = true;
        this.color = 'yellow';
      }

      update(wallSpeed) {
        // Apply acceleration (gravity)
        this.v.y += this.a.y;
        
        // Apply friction to horizontal velocity
        this.v.x *= 0.95;

        // Apply velocity to position
        this.p.x += this.v.x;
        // Compensate for walls moving up (makes player appear stationary relative to the ground if not falling)
        this.p.y += this.v.y - wallSpeed; 

        // Check for boundary collisions
        if (this.p.x < 0) {
          this.p.x = 0;
          this.v.x = 0;
        }
        if (this.p.x + this.width > w) {
          this.p.x = w - this.width;
          this.v.x = 0;
        }

        // Check if player is falling
        if (this.v.y > 0) {
          this.isFalling = true;
          this.isJumping = false;
        }
      }

      draw() {
        ctx.fillStyle = this.color;
        ctx.fillRect(this.p.x, this.p.y, this.width, this.height);
      }
      
      jump() {
          if (!this.isJumping && !this.isFalling) {
              this.isJumping = true;
              this.v.y = -10; // Initial jump velocity
          }
      }
    }

    // 調整畫布大小
    function resize() {
      w = window.innerWidth;
      h = window.innerHeight;
      wh = window.innerHeight; // Keep wh for vertical checks
      canvas.width = w;
      canvas.height = h;
      
      // Update player position if needed, or simply recenter
      if (game && !game.isGameOver) {
          // If the player is on screen, adjust position proportionally or re-center if out of bounds
          game.player.p.x = Math.min(game.player.p.x, w - game.player.width);
      }
    }
    
    // 主遊戲循環
    function animate() {
      requestAnimationFrame(animate);

      if (isGameRunning && game) {
        game.update();
        game.draw();
      } else if (game && game.isGameOver) {
          game.draw(); // Draw game over screen
      }
    }
    
    // 遊戲開始函數
    function startGame() {
      // 移除 dat.gui 相關程式碼
      // if (gui) { gui.destroy(); } 
      
      game = new Game();
      isGameRunning = true;
      startButton.classList.add('hidden');
      nameModal.classList.add('hidden');
    }
    
    // 重新開始遊戲
    function restartGame() {
        if (game.isGameOver) {
            startGame();
        }
    }
    
    // 提交名字
    function submitName() {
        const name = nameInput.value.trim();
        if (name.length > 0) {
            playerName = name;
            nameModal.classList.add('hidden');
            startButton.classList.remove('hidden');
        } else {
            alert('請輸入有效的名字！');
        }
    }

    // 鍵盤和滑鼠/觸控事件處理
    function handleInput(e) {
      if (game && !game.isGameOver) {
        // Only handle movement if game is running and player is on screen
        if (isGameRunning) {
            const player = game.player;
            // Key mapping: Left=A/Left Arrow, Right=D/Right Arrow, Jump=Space/Up Arrow/Click/Touch
            if (e.type === 'keydown') {
                switch (e.key) {
                    case 'ArrowLeft':
                    case 'a':
                    case 'A':
                        player.v.x = -5;
                        break;
                    case 'ArrowRight':
                    case 'd':
                    case 'D':
                        player.v.x = 5;
                        break;
                    case ' ':
                    case 'ArrowUp':
                        player.jump();
                        break;
                }
            }
        }
      } else if (game && game.isGameOver) {
          // Restart game on any click/key press during game over
          restartGame();
      }
    }
    
    // Touch/Click handler for jump and restart
    function handleClick(e) {
        if (game && !game.isGameOver && isGameRunning) {
            // Treat tap/click as jump
            game.player.jump();
        } else if (game && game.isGameOver) {
            // Restart game on click
            restartGame();
        } else if (!isGameRunning && nameModal.classList.contains('hidden')) {
            // Start button click
            if (e.target.id === 'startButton') {
                startGame();
            }
        }
    }
    
    // Prevent default touch actions (scrolling, zooming)
    const preventDefault = (e) => e.preventDefault();

    // 初始化
    window.onload = function() {
      // Initialize Firebase (Async operation)
      initializeFirebase();
      
      resize();
      window.addEventListener('resize', resize);
      
      // Control input listeners
      window.addEventListener('keydown', handleInput);
      canvas.addEventListener('click', handleClick);
      canvas.addEventListener('touchstart', handleClick, { passive: false });
      
      // Prevent scrolling/pinch zoom on the entire document
      document.addEventListener('touchstart', preventDefault, { passive: false });
      document.addEventListener('touchmove', preventDefault, { passive: false });
      document.addEventListener('touchend', preventDefault, { passive: false });
      document.addEventListener('touchcancel', preventDefault, { passive: false });
      
      // Name modal event listeners
      document.getElementById('submitName').addEventListener('click', submitName);
      document.getElementById('nameInput').addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
          submitName();
        }
      });
      
      // Show name modal first
      nameModal.classList.remove('hidden');

      // Start the animation loop
      animate();
    };

    // Note: The original modification to Game.prototype.update has been moved
    // into the class definition for cleaner structure, ensuring the answer assignment logic is present.
    // The previous modification was:
    /*
    const originalGameUpdate = Game.prototype.update;
    Game.prototype.update = function() {
      originalGameUpdate.call(this);
      
      // Assign answers to new normal and jump walls
      this.walls.forEach(wall => {
        if ((wall.type === "normal" || wall.type === "jump") && 
            wall.answer === null && 
            !wall.answerUsed && 
            wall.p.y < wh - 100) { // Only assign to walls that are in view
          // Randomly assign correct or wrong answer
          if (Math.random() > 0.5) {
            wall.answer = this.correctAnswer;
          } else {
            wall.answer = this.wrongAnswer;
          }
        }
      });
    };
    */
    // This logic is now directly inside the Game.update() method for encapsulation.
  </script>
</body>
</html>
