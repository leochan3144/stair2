<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <!-- Ensure viewport is set for mobile responsiveness -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  <title>小朋友下樓梯</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.9/dat.gui.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/1.20.4/TweenMax.min.js"></script>
  <style>
    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      background-color: black;
      font-family: Arial, sans-serif;
    }

    canvas {
      display: block;
      max-width: 100%;
      height: auto;
      /* Prevent touch default actions on canvas */
      touch-action: none;
    }

    button {
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      padding: 10px 70px;
      background-color: rgba(255, 255, 255, 0.2);
      color: white;
      border-radius: 500px;
      outline: none;
      font-size: 50px;
      letter-spacing: 1px;
      cursor: pointer;
      border: none;
      box-shadow: 0px 0px 20px rgba(255, 255, 255, 0.3);
      z-index: 10;
    }

    button:hover {
      background-color: rgba(255, 255, 255, 0.3);
    }
    
    /* Leaderboard styles */
    #leaderboard {
      position: fixed;
      top: 50%; /* Adjusted position: Center vertically */
      transform: translateY(-50%); /* Adjust up by half its height for true centering */
      right: 10px;
      background-color: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 10px;
      border-radius: 8px;
      font-size: 12px;
      z-index: 20;
      min-width: 150px;
      box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
    }
    
    #leaderboard h3 {
      margin: 0 0 8px 0;
      text-align: center;
      color: #ffdd38;
      font-size: 16px;
    }
    
    #leaderboard ol {
      padding-left: 15px;
      margin: 0;
    }
    
    #leaderboard li {
      margin-bottom: 3px;
      color: white;
    }
    
    .current-score {
      color: #53d337 !important;
      font-weight: bold;
    }
    
    /* Name input modal */
    #nameModal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.8);
      z-index: 30;
      justify-content: center;
      align-items: center;
    }
    
    .modal-content {
      background-color: rgba(50, 50, 50, 0.95);
      padding: 30px;
      border-radius: 10px;
      text-align: center;
      box-shadow: 0 0 30px rgba(255, 255, 255, 0.5);
    }
    
    #nameInput {
      padding: 10px;
      font-size: 18px;
      border: 2px solid #53d337;
      border-radius: 5px;
      background-color: #222;
      color: white;
      margin: 10px;
      width: 200px;
      text-align: center;
    }
    
    #nameInput:focus {
      outline: none;
      border-color: #ffdd38;
    }
    
    #submitName {
      padding: 10px 20px;
      font-size: 18px;
      background-color: #53d337;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      margin-top: 10px;
      transition: background-color 0.2s;
    }
    
    #submitName:hover {
      background-color: #42b02b;
    }
    
    .modal-title {
      color: #ffdd38;
      font-size: 24px;
      margin-bottom: 20px;
    }
    
    .score-display {
      font-size: 20px;
      margin: 15px 0;
      color: #53d337;
    }
    
    /* Touch controls */
    #touchControls {
      position: fixed;
      bottom: 20px;
      left: 0;
      width: 100%;
      display: flex;
      justify-content: space-between; /* Space out the left and right controls */
      padding: 0 40px; /* More padding on the sides for better touch targets */
      box-sizing: border-box;
      z-index: 20;
    }
    
    .touch-btn {
      width: 80px;
      height: 80px;
      background-color: rgba(255, 255, 255, 0.3); /* Slightly brighter for visibility */
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 36px; /* Larger icon */
      font-weight: bold;
      color: white;
      user-select: none;
      -webkit-tap-highlight-color: rgba(255, 255, 255, 0.5);
      touch-action: manipulation; /* Prevent double-tap zoom/context menu */
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
      transition: background-color 0.1s;
    }

    .touch-btn:active {
      background-color: rgba(255, 255, 255, 0.5);
      transform: scale(0.95);
    }
    
    /* Hide dat.GUI on small screens */
    @media (max-width: 768px) {
        .dg.main {
            display: none !important;
        }
    }
  </style>
</head>
<body>
  <canvas id="mycanvas"></canvas>
  <!-- Added ID for event listener attachment and removed inline onclick -->
  <button id="startButton">Start</button>

  <!-- Leaderboard -->
  <div id="leaderboard">
    <h3>排行榜</h3>
    <ol id="scoresList"></ol>
  </div>

  <!-- Name input modal -->
  <div id="nameModal">
    <div class="modal-content">
      <div class="modal-title">恭喜進入前十名！</div>
      <div class="score-display">階數: <span id="currentScoreDisplay">0</span></div>
      <input type="text" id="nameInput" placeholder="輸入您的姓名" maxlength="10">
      <br>
      <button id="submitName">提交</button>
    </div>
  </div>
  
  <!-- Touch Controls -->
  <!-- Note: The position of the touch controls is optimized for mobile thumb interaction -->
  <div id="touchControls">
    <!-- Group for left control -->
    <div style="flex-grow: 1; display: flex; justify-content: flex-start;">
      <div class="touch-btn" id="leftBtn">←</div>
    </div>
    <!-- Group for right control -->
    <div style="flex-grow: 1; display: flex; justify-content: flex-end;">
      <div class="touch-btn" id="rightBtn">→</div>
    </div>
  </div>

  <!-- Audio elements -->
  <!-- Note: Audio elements are kept here, but mobile browsers often require user interaction (e.g., a button click) to start audio playback. The start button handles this. -->
  <audio id="musicBg" src="sound/bgm.mp3" preload="auto"></audio>
  <audio id="transmiting" src="sound/transmit.mp.mp3" preload="auto"></audio>
  <audio id="hurt" src="sound/hurt.mp3" preload="auto"></audio>
  <audio id="fade" src="sound/fade.mp3" preload="auto"></audio>
  <audio id="dead" src="sound/help.mp3" preload="auto"></audio>
  <audio id="step" src="sound/step.mp3" preload="auto"></audio>
  <audio id="jump" src="sound/jump.mp3" preload="auto"></audio>

  <script>
    //環境變數
    var updateFPS = 30
    var showMouse = true
    var time = 0
    var bgColor ="black"

    //控制
    var controls = {
      value: 0
    }
    // Only initialize dat.GUI if not on a small screen
    if (window.innerWidth > 768) {
        var gui = new dat.GUI()
        gui.add(controls,"value",-2,2).step(0.01).onChange(function(value){})
    }

    // Attempt to start BGM, but rely on user interaction (Start button) if this fails
    document.getElementById('musicBg').play().catch(e => console.log('BGM playback prevented by browser, will start on user interaction.'));
    document.getElementById('musicBg').volume=0.4
    document.getElementById('transmiting').volume=0.3
    document.getElementById('step').volume=0.7
    document.getElementById('musicBg').addEventListener('ended', function(){
    this.currentTime = 0;
    this.play();
    }, false);

    //------------------------
    // Vec2

    class Vec2{
      constructor(x,y){
        this.x = x
        this.y = y
      }
      set(x,y){
        this.x =x
        this.y =y
      }
      move(x,y){
        this.x+=x
        this.y+=y
      }
      add(v){
        return new Vec2(this.x+v.x,this.y+v.y)
      }
      sub(v){
        return new Vec2(this.x-v.x,this.y-v.y)
      }
      mul(s){
        return new Vec2(this.x*s,this.y*s)
      }
      get length(){
        return Math.sqrt(this.x*this.x+this.y*this.y)
      }
      set length(nv){
        let temp = this.unit.mul(nv)
        this.set(temp.x,temp.y)
      }
      clone(){
        return new Vec2(this.x,this.y)
      }
      toString(){
        return `(${this.x}, ${this.y})`
      }
      equal(v){
        return this.x==v.x && this.y ==v.y
      }
      get angle(){
        return Math.atan2(this.y,this.x)  
      }
      get unit(){
        return this.mul(1/this.length)
      }
      
    }

    //------
    var canvas = document.getElementById("mycanvas")
    var ctx = canvas.getContext("2d")
    ctx.circle= function(v,r){
      this.arc(v.x,v.y,r,0,Math.PI*2)
    }
    ctx.line= function(v1,v2){
      this.moveTo(v1.x,v1.y)
      this.lineTo(v2.x,v2.y)
    }

    function playSound(id){
      
      document.getElementById(id).currentTime=0
      // Check if it's currently paused before trying to play (for mobile)
      document.getElementById(id).play().catch(e => console.log('Sound playback failed:', id, e));
    }

    //排行榜相關函數
    function getLeaderboard() {
      const saved = localStorage.getItem('stairGameLeaderboard');
      return saved ? JSON.parse(saved) : [];
    }

    function saveLeaderboard(scores) {
      localStorage.setItem('stairGameLeaderboard', JSON.stringify(scores));
    }

    function updateLeaderboardDisplay() {
      const scores = getLeaderboard();
      const scoresList = document.getElementById('scoresList');
      scoresList.innerHTML = '';
      
      scores.slice(0, 10).forEach((entry, index) => {
        const li = document.createElement('li');
        li.textContent = `${entry.name}: ${entry.score}階`;
        if (entry.isCurrent) {
          li.classList.add('current-score');
        }
        scoresList.appendChild(li);
      });
    }

    function checkNewRecord(score) {
      const scores = getLeaderboard();
      const newEntry = { score: score, name: '玩家', isCurrent: false };
      
      // Add current score temporarily to check if it's in top 10
      scores.push(newEntry);
      scores.sort((a, b) => b.score - a.score);
      
      // Check if the current score made it into the top 10 (index < 10)
      const rank = scores.findIndex(entry => entry.score === score && entry.name === '玩家' && entry.isCurrent === false);

      if (rank !== -1 && rank < 10) {
        // Show name input modal
        document.getElementById('currentScoreDisplay').textContent = score;
        document.getElementById('nameModal').style.display = 'flex';
        document.getElementById('nameInput').focus();
        
        // Mark this entry as current for display
        newEntry.isCurrent = true;
        scores[scores.findIndex(entry => entry.score === score && entry.name === '玩家' && entry.isCurrent === false)] = newEntry;

        // Save temporarily
        saveLeaderboard(scores);
        updateLeaderboardDisplay();
        return true;
      }
      
      // Clean up the temporary entry if it's not a top score
      if (rank === -1) {
        scores.pop(); // Remove the non-top score
        saveLeaderboard(scores);
        updateLeaderboardDisplay();
      }

      return false;
    }

    function submitName() {
      const name = document.getElementById('nameInput').value.trim() || '無名氏';
      const score = parseInt(document.getElementById('currentScoreDisplay').textContent);
      
      const scores = getLeaderboard();
      // Find the temporary entry marked as current
      const currentIndex = scores.findIndex(entry => entry.score === score && entry.isCurrent);
      
      if (currentIndex !== -1) {
        scores[currentIndex].name = name;
        scores[currentIndex].isCurrent = false; // Unmark as current
        scores.sort((a, b) => b.score - a.score);
        saveLeaderboard(scores);
      }
      
      document.getElementById('nameModal').style.display = 'none';
      updateLeaderboardDisplay();
    }

    //遊戲物件
    class Game{
      constructor(){
        this.player = null
        this.walls = []
        this.width = 700
        this.height = wh
        this.walltypes = [
          "normal","jump","slideLeft","slideRight",
          "hurt","fade"
        ]
        this.hurt=0
        this.playing=false
        this.keystatus = {
          left: false,
          right: false,
          up: false,
          down: false,
        }
        this.time=0
        this.currentMathProblem = null
        this.correctAnswer = null
        this.wrongAnswer = null
      }
      
      generateMathProblem() {
        // Generate a random math problem (addition or subtraction)
        const operation = Math.random() > 0.5 ? '+' : '-';
        const num1 = Math.floor(Math.random() * 10) + 1; // 1-10
        let num2 = Math.floor(Math.random() * 10) + 1; // 1-10
        
        // For subtraction, ensure result is positive
        if (operation === '-' && num2 > num1) {
          [num1, num2] = [num2, num1]; // Swap to ensure positive result
        }
        
        const problem = `${num1}${operation}${num2}`;
        const result = operation === '+' ? num1 + num2 : num1 - num2;
        
        // Generate wrong answer
        let wrongResult;
        do {
          const offset = Math.floor(Math.random() * 5) + 1; // 1-5
          const sign = Math.random() > 0.5 ? 1 : -1;
          wrongResult = result + (offset * sign);
        } while (wrongResult === result);
        
        this.currentMathProblem = problem;
        this.correctAnswer = result;
        this.wrongAnswer = wrongResult;
      }
      
      init(){
        //初始化先推一些牆壁進去
        this.walls=[]
        this.generateMathProblem(); // Generate first math problem
        
        for(var i=0;i<wh/150;i++){
          this.walls.push(new Wall({
            p: new Vec2(Math.random()*this.width,i*150+100),
            type:  this.walltypes[parseInt(Math.random()*this.walltypes.length)]
          })) 
        }
        this.player = new Player({
          p: new Vec2(ww/2,200)
        })    
      }
      start(){
        
        document.querySelector('#startButton').style.display = 'none'
        this.init()
        this.playing=true
        this.time=0
      }
      end(){
        document.querySelector('#startButton').style.display = 'block'
        playSound('dead')  
        this.playing=false
        
        // 檢查是否進入排行榜
        const finalScore = parseInt(this.time/100);
        checkNewRecord(finalScore);
      }
      update(){
        this.time++
        //更新玩家跟左右走
        this.player.update()
        if (this.keystatus.left){
          this.player.p.x-=8
        }
        if (this.keystatus.right){
          this.player.p.x+=8
        }
        
        //推入新的地板
        if (this.time % 20 === 0){
          // Generate new math problem when new floor is added
          if (this.time % 200 === 0) { // Every 10 new floors
            this.generateMathProblem();
          }
          
          this.walls.push(new Wall({
            p: new Vec2(Math.random()*this.width,this.height),
            type:  this.walltypes[parseInt(Math.random()*this.walltypes.length)]
          }))
        }
        
        let touching = false
        //處理地板跟人的碰撞
        this.walls.forEach(wall=>{  
          wall.update() 
          if (wall.p.x-wall.width/2<this.player.p.x+this.player.width/2
              &&   wall.p.x+wall.width/2>this.player.p.x-this.player.width/2){
            if (this.player.p.y>wall.p.y 
                && this.player.p.y<wall.p.y+wall.height+10){ 
              touching=true
              wall.step(this.player)
              this.player.lastBlock=wall
              
              // Check for answer collision
              if (wall.answer !== null && !wall.answerUsed) {
                if (wall.answer === this.correctAnswer) {
                  this.player.bloodDelta(1);
                  wall.answerUsed = true;
                  // Immediately clear the answer so it doesn't get triggered again
                  wall.answer = null; 
                } else if (wall.answer === this.wrongAnswer) {
                  this.player.bloodDelta(-1);
                  wall.answerUsed = true;
                  // Immediately clear the answer so it doesn't get triggered again
                  wall.answer = null;
                }
              }
            }
          }
        }) 
        
        //如果沒有任何接觸，清掉上一個接觸的紀錄
        if (!touching){
          this.player.lastBlock=null
          document.getElementById("transmiting").pause()
        }

        this.walls = this.walls.filter(wall=>wall.active)
        
        //被上面刺到
        if (this.player.p.y-this.player.height<0){
          if (this.hurt==0){   
            this.hurt=1
            this.player.bloodDelta(-4)
            this.player.v.y=2
            this.player.p.y=10
            TweenMax.to(this,0.5,{hurt: 0})
          }
        }
        
        //左右限制
        if (this.player.p.x-this.player.width/2<0){
          this.player.p.x=this.player.width/2
        }
        if (this.player.p.x+this.player.width/2>this.width){
          this.player.p.x=this.width-this.player.width/2
        }
        
        //掉到懸崖
        if (this.player.p.y>wh+this.player.height){
          game.end()
        }
      }
      draw(){
        ctx.save()
          //移動座標到遊戲左邊界
          ctx.translate(ww/2-this.width/2,0)
          let span = this.width/60
          ctx.beginPath()
          for(var i=0;i<=this.width/span;i++){
            ctx.lineTo(i*span,(i%2)*30)
          }  
          ctx.fillStyle="white"
          ctx.fill()
        
          //繪製界線
          ctx.beginPath()
          ctx.moveTo(0,0)
          ctx.lineTo(0,wh)
          ctx.moveTo(this.width,0)
          ctx.lineTo(this.width,wh)
          ctx.strokeStyle="rgba(255,255,255,0.3)"
          ctx.stroke()
        
          this.player.draw()
          this.walls.forEach(wall=>wall.draw())
        ctx.restore()
        
        //疼痛的血幕
        ctx.fillStyle="rgba(255,0,0,"+this.hurt+")"
        ctx.fillRect(0,0,ww,wh)
        
        //繪製血量
        this.player.drawBlood()
        
        //繪製階數
        ctx.fillStyle='white'
        ctx.font="30px Arial" /* Reduced font size for mobile view */
        ctx.fillText( "地下："+(parseInt(this.time/100))+"階",40,40) /* Moved up for better placement */
        
        //繪製數學題
        if (this.currentMathProblem) {
          ctx.font="40px Arial"
          ctx.fillText(`Q: ${this.currentMathProblem}=?`, 40, 90); /* Moved and added Q: */
        }
        
        ctx.font="10px Arial"
      }
    }

    //玩家物件
    class Player{
      constructor(args){
        let def = {
          p: new Vec2(0,0),
          v: new Vec2(0,0),
          a: new Vec2(0,1), 
          width: 40,
          height: 55,
          blood: 10,
          maxBlood: 10,
          lastBlock: null,
        }
        Object.assign(def,args)
        Object.assign(this,def)
      }
      update(){
        this.p=this.p.add(this.v)
        this.v=this.v.add(this.a)
        
      }
      draw(){
        //畫出人形狀
        ctx.beginPath()
        
        ctx.save()
          ctx.translate(this.p.x,this.p.y)
          ctx.fillStyle="#0047ba"
          ctx.fillRect(-this.width/2,-this.height,this.width,this.height)
          ctx.fillStyle="#ffdd38"

          ctx.fillRect(-5,-30,10,10)

          //左右眼
          ctx.beginPath()
          ctx.arc(-6,-40,5,0,Math.PI*2)
          ctx.arc(+6,-40,5,0,Math.PI*2)
          ctx.fillStyle="white"
          ctx.fill()

          //瞳孔
          ctx.beginPath()
          ctx.arc(-6,-40,3,0,Math.PI*2)
          ctx.arc(+6,-40,3,0,Math.PI*2)
          ctx.fillStyle="black"   
          ctx.fill()
        
        //右手
        ctx.save()
            ctx.translate(+this.width/2,-40)
            ctx.rotate(-Math.log(this.v.y/2))
            ctx.fillStyle="#416ee0"
            ctx.fillRect(0,0,8,this.height/2 )

          ctx.restore()

          //左手
          ctx.save()
            ctx.translate(-this.width/2,-40)
            ctx.rotate(Math.log(this.v.y/2))
            ctx.fillStyle="#416ee0"
            ctx.fillRect(-8,0,8,this.height/2 )

          ctx.restore()

        ctx.restore()
      }
      //畫出血量
      drawBlood(){
        // Adjusted position for mobile layout
        const startX = ww - 250; 
        const startY = 30;

        for(var i=0;i<10;i++){
          ctx.fillStyle=i<this.blood?"red":"rgba(255,255,255,0.2)"
          ctx.fillRect(startX + i * 15 + (i - 1) * 4, startY, 10, 20) /* Reduced height for mobile */
        }
      }
      //扣血量的統一管理
      bloodDelta(delta){
        if (delta<0){
          playSound('hurt')
        }
        this.blood+=delta
        if (this.blood>this.maxBlood){
          this.blood=this.maxBlood
        }
        if (this.blood<=0){
          
         
          this.blood=0
          game.end()
        }
      }
    }

    //-----------------
    //     牆壁物件
    //-----------------
    class Wall{
      constructor(args){
        let def = {
          p: new Vec2(0,0),
          v: new Vec2(0,-4),
          a: new Vec2(0,0),
          width: 150,
          height: 20, 
          extraHeight: 0,
          type: "normal",
          active: true,
          answer: null,
          answerUsed: false
        }
        Object.assign(def,args)
        Object.assign(this,def)
      }
      update(){
        this.p=this.p.add(this.v)
        this.v=this.v.add(this.a)
        if (this.p.y<-20){
          this.active=false
        }
      }
      
      draw(){
        ctx.save()
        //移動到牆壁位置
        ctx.translate(this.p.x-this.width/2,this.p.y-this.extraHeight)
          ctx.fillStyle="white"
          // ctx.fillText(this.type,0,30) // Removed debug text
          
          if (this.type=="normal" || this.type=="hurt"){
            
            ctx.fillStyle="#888" 
            ctx.fillRect(0,0,this.width,this.height/2)
          }
        
          //受傷
          if (this.type=="hurt"){
            ctx.beginPath()
            let span = this.width/16
            for(var i=0;i<=this.width/span;i+=1){ 
              ctx.lineTo(0+i*span,-(i%2)*15)
            }
            ctx.fillStyle="#ddd" 
            ctx.fill()
          }
        
          //跳跳板
          if (this.type=="jump"){
            ctx.fillStyle="#53d337"
            ctx.fillRect(0,0,this.width,5)
            ctx.fillRect(0,this.height+this.extraHeight,this.width,5)
            
          }
          //穿透
          if (this.type=="fade"){
            ctx.fillStyle="#ffd428"
            ctx.fillRect(0,0,this.width,this.height)
            
          }
          //  左滑跟右滑
          if (this.type=="slideLeft" || this.type=="slideRight"){
            for(var i=-1;i<this.width/20;i+=1){ 
              let x = 0+i*20+(time%20)* (this.type=="slideLeft"?-1:1)
              let width = 10
              if (x<0){
                x=0
              } 
              if (x+width>this.width){
                width = this.width-x<0?0:(this.width-x)
              }
              ctx.fillStyle="red"
              ctx.save()
              //傾斜
              ctx.transform(1, 0,0.5, 1, 0, 0)
              ctx.fillRect(x ,0,width,this.height)
              ctx.restore()
            }
          }
          
          // Draw answer if exists
          if (this.answer !== null && !this.answerUsed) {
            ctx.fillStyle = "cyan"; /* Changed color to cyan for better contrast */
            ctx.font = "24px Arial"; /* Larger font for mobile */
            ctx.fillText(this.answer, this.width/2 - 15, -10);
          }
          
        ctx.restore()
      } 
      //不同地板踩到時的影響
      step(player){
        player.v.y=0
        if (player.lastBlock!=this){
          // REMOVED: player.bloodDelta(1) 
          if (this.type=="normal"){
            
            playSound('step')
          }
          if (this.type=="fade"){
            
            playSound('fade')
          }
          if (this.type=="hurt"){
            
            playSound('hurt')
          }
          if (this.type=="jump"){
            
            playSound('jump')
          }
        }
        if (this.type=="normal"){
          player.p.y = this.p.y
        }
        if (this.type=="hurt"){
          player.p.y = this.p.y
          
          if (player.lastBlock!=this){
            player.bloodDelta(-4) 
            game.hurt=1
            TweenMax.to( game,0.2,{hurt: 0} )
          }
        }
        if (this.type=="jump"){
          player.v.y = -15
          this.extraHeight=10
          TweenMax.to(this,0.2,{extraHeight: 0})
        } 
        if (this.type=="slideLeft"){ 
          player.p.x-=3
          player.p.y = this.p.y
             document.getElementById("transmiting").play()
        }
        if (this.type=="slideRight"){
          player.p.x+=3
          player.p.y = this.p.y
             document.getElementById("transmiting").play()
        }
        if (this.type=="fade"){
          player.p.y-=3
          // player.p.y = this.p.y
        }
      }
      
    }

    function initCanvas(){
      ww = canvas.width = window.innerWidth
      wh = canvas.height = window.innerHeight
      // Adjust game width to match canvas width on small screens
      if (game) {
        game.width = ww;
        game.height = wh;
      }
    }
    initCanvas()

    var game = new Game

    function init(){
      game.init()
      updateLeaderboardDisplay(); // 初始化排行榜
    }
    function update(){
      time++
      if (game.playing){
        game.update()
      }
    }
    function draw(){
       //清空背景
      ctx.fillStyle=bgColor
      ctx.fillRect(0,0,ww,wh)
      
      //-------------------------
      //   在這裡繪製
      
      game.draw()
      
      //-----------------------
      //繪製滑鼠座標 (Only for debug, safe to keep)
      
      ctx.fillStyle="red"
      ctx.beginPath()
      ctx.circle(mousePos,2)
      ctx.fill()
       
      ctx.save()
      ctx.beginPath()
      ctx.translate(mousePos.x,mousePos.y)
        ctx.strokeStyle="red"
        let len = 20
        ctx.line(new Vec2(-len,0),new Vec2(len,0))
        ctx.line(new Vec2(0,-len),new Vec2(0,len))
        ctx.fillText(mousePos,10,-10)
        ctx.stroke()
      ctx.restore()
      
      //schedule next render

      requestAnimationFrame(draw)
    }
    function loaded(){
      initCanvas()
      init()
      
      // FIX: Attach Start button listener for reliable touch interaction
      document.getElementById('startButton').addEventListener('click', function() {
          // Play BGM here, as it's user-initiated
          document.getElementById('musicBg').play().catch(e => console.log('BGM playback failed on start.'));
          game.start();
      });
      
      requestAnimationFrame(draw)
      setInterval(update,1000/updateFPS)
    }
    window.addEventListener("load",loaded)
    window.addEventListener("resize",initCanvas)

    //滑鼠事件跟紀錄
    var mousePos = new Vec2(0,0)
    var mousePosDown = new Vec2(0,0)
    var mousePosUp = new Vec2(0,0)

    window.addEventListener("mousemove",mousemove)
    window.addEventListener("mouseup",mouseup)
    window.addEventListener("mousedown",mousedown)
    function mousemove(evt){
      mousePos.set(evt.clientX,evt.clientY)
    }
    function mouseup(evt){
      mousePos.set(evt.clientX,evt.clientY)
      mousePosUp = mousePos.clone()
      
    }
    function mousedown(evt){
      mousePos.set(evt.clientX,evt.clientY)
      mousePosDown = mousePos.clone()
    }

    // keystatus= {}
    window.addEventListener('keydown',function(evt){
      let key = evt.key.replace("Arrow","").toLowerCase()
      game.keystatus[key]=true
    })

    window.addEventListener('keyup',function(evt){
      let key = evt.key.replace("Arrow","").toLowerCase()
      game.keystatus[key]=false
    })

    // Touch controls for mobile devices
    const leftBtn = document.getElementById('leftBtn');
    const rightBtn = document.getElementById('rightBtn');
    
    // Function to prevent touch default actions (like scrolling or context menus)
    function preventDefault(e) {
      if (e.target.tagName !== 'INPUT' && e.target.id !== 'nameInput') {
        e.preventDefault();
      }
    }
    
    // Left button touch events
    leftBtn.addEventListener('touchstart', function(e) {
      e.preventDefault();
      game.keystatus.left = true;
    }, { passive: false });
    
    ['touchend', 'touchcancel'].forEach(event => {
      leftBtn.addEventListener(event, function(e) {
        // Removed e.preventDefault() here for better touch release reliability
        game.keystatus.left = false;
      }, { passive: false });
    });
    
    // Right button touch events
    rightBtn.addEventListener('touchstart', function(e) {
      e.preventDefault();
      game.keystatus.right = true;
    }, { passive: false });
    
    ['touchend', 'touchcancel'].forEach(event => {
      rightBtn.addEventListener(event, function(e) {
        // Removed e.preventDefault() here for better touch release reliability
        game.keystatus.right = false;
      }, { passive: false });
    });
    
    // Global touch prevention: Added touchend/touchcancel globally for robustness
    document.addEventListener('touchstart', preventDefault, { passive: false });
    document.addEventListener('touchmove', preventDefault, { passive: false });
    document.addEventListener('touchend', preventDefault, { passive: false });
    document.addEventListener('touchcancel', preventDefault, { passive: false });
    
    // Name modal event listeners
    document.getElementById('submitName').addEventListener('click', submitName);
    document.getElementById('nameInput').addEventListener('keypress', function(e) {
      if (e.key === 'Enter') {
        submitName();
      }
    });
    
    // Add answer generation to walls
    const originalGameUpdate = Game.prototype.update;
    Game.prototype.update = function() {
      originalGameUpdate.call(this);
      
      // Assign answers to new normal and jump walls
      this.walls.forEach(wall => {
        // Ensure the wall is an answerable type, hasn't been assigned an answer, and is visible
        if ((wall.type === "normal" || wall.type === "jump") && 
            wall.answer === null && 
            !wall.answerUsed && 
            wall.p.y > 150 && wall.p.y < wh - 100) { 
          
          // Randomly assign either the correct answer, the wrong answer, or leave it blank
          const choice = Math.random();
          if (choice < 0.33) { // 33% chance for correct answer
            wall.answer = this.correctAnswer;
          } else if (choice < 0.66) { // 33% chance for wrong answer
            wall.answer = this.wrongAnswer;
          }
          // The remaining 34% of platforms will have no number, making it slightly easier/more platform-focused
        }
      });
    };
  </script>
</body>
</html>
